# ğŸ“Œ 498. Diagonal Traverse

---

# ğŸ§  Problem Type

* **Category:** Matrix Traversal
* **Pattern:** Simulation + Direction Switching
* **Key Concept:** Move diagonally while handling boundaries

---

# ğŸ¯ Core Insight

All elements on the same diagonal share:

```
row + col = constant
```

Traversal alternates direction:

* If `(row + col) % 2 == 0` â†’ move **UP-RIGHT**
* If `(row + col) % 2 == 1` â†’ move **DOWN-LEFT**

This eliminates needing an explicit direction variable.

---

# ğŸ” Movement Rules

## ğŸ”¼ Up-Right Move

```
row--
col++
```

### Boundary Handling:

* If at last column â†’ move down
* If at first row â†’ move right

---

## ğŸ”½ Down-Left Move

```
row++
col--
```

### Boundary Handling:

* If at last row â†’ move right
* If at first column â†’ move down

---

# ğŸ§© Algorithm Structure

1. Start at `(0,0)`
2. Loop `m * n` times
3. Add current element
4. Decide direction using `(row + col) % 2`
5. Handle boundaries carefully

---

# â± Complexity

* **Time:** O(m Ã— n)
* **Space:** O(1) (excluding output array)

---

# ğŸ§  Why `(row + col) % 2` Works?

Even diagonals â†’ upward
Odd diagonals â†’ downward

Example:

Matrix:

```
1 2 3
4 5 6
7 8 9
```

Diagonal indices:

```
0
1 1
2 2 2
3 3
4
```

Alternate direction per diagonal index.

---

# ğŸš¨ Common Mistakes

âŒ Forgetting boundary checks
âŒ Moving outside matrix
âŒ Updating row/col in wrong order
âŒ Confusing which boundary to check first

---

# ğŸ† Interview Explanation (Short Version)

> I traverse the matrix and alternate direction based on parity of (row + col). I carefully handle boundary cases when reaching edges to avoid going out of bounds.

---

# ğŸ”¥ Pattern Tag

Remember this as:

ğŸ‘‰ **â€œDiagonal traversal with parity-based direction controlâ€**

Similar problems:

* Spiral Matrix
* Zigzag Level Order
* Matrix simulation problems
