# ğŸ 3668. Restore Finishing Order

---

# ğŸ§  Problem Type

* **Category:** Arrays
* **Pattern:** Filtering / Membership check
* **Concept:** Preserve order while selecting subset

---

# ğŸ¯ Core Understanding

* `order` â†’ Final race finishing order (permutation of 1 to n)
* `friends` â†’ IDs of your friends (sorted, but sorting not needed)

We must:

> Return friends in the same order they appear in `order`.

âš ï¸ Important:
We do NOT sort.
We do NOT rearrange.
We just preserve `order`.

---

# ğŸ” Algorithm (Optimal Approach)

1. Put all `friends` into a `HashSet`.
2. Traverse `order`.
3. If element exists in set â†’ add to result.
4. Return result array.

---

# ğŸ’» Clean Implementation Idea

```
Create HashSet of friends
For each id in order:
    if id exists in set:
        add to result
Return result
```

---

# â± Complexity

* **Time:** O(n)
* **Space:** O(f) (max 8)

Since:

* `n â‰¤ 100`
* `friends.length â‰¤ 8`

Even O(n Ã— f) brute force works.

---

# ğŸ§© Why HashSet?

* Membership check becomes O(1)
* Cleaner logic
* Interview-friendly

---

# ğŸ“Œ Key Insight

This is NOT:

* Sorting
* Two pointers
* Binary search

Itâ€™s simply:

> â€œFilter while preserving original orderâ€

---

# ğŸ† Interview Explanation (Short Version)

> I store friends in a HashSet for constant-time lookup. Then I iterate through the finishing order and collect IDs that are in the set. This preserves the finishing order automatically.

---

# ğŸ”¥ Common Mistake

âŒ Sorting friends
âŒ Changing order
âŒ Wrong method name in LeetCode

---

# ğŸ§  Pattern Tag

Remember this as:

ğŸ‘‰ **â€œFilter by membership while preserving sequence orderâ€**

This pattern appears in:

* Intersection problems
* Subsequence extraction
* Filtering arrays
