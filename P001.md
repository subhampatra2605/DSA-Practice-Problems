## ðŸ”¹ **Problem Statement**

Given an integer array `nums`, check if **any value appears at least twice** in the array.
Return `true` if a duplicate exists, otherwise `false`.

---

## ðŸ“¥ **Example Input**

```
nums = [1, 2, 3, 1]
```

## ðŸ“¤ **Expected Output**

```
true
```

---

# ðŸ§  **Brute Force Approach**

### âž¤ **Logic**

Compare every pair using two nested loops.

### âž¤ **Code Concept**

For each `i`, check all elements after it (`j = i+1 â†’ n`).

### âž¤ **Time Complexity:**

O(nÂ²)

### âž¤ **Space Complexity:**

O(1)

### âž¤ Why it's bad?

Very slow for large arrays.

---

# ðŸ™‚ **Better Approach (Sorting)**

### âž¤ **Logic**

If the array is sorted, duplicates will be adjacent.

### âž¤ **Steps**

1. Sort the array
2. If any `nums[i] == nums[i+1]` â†’ duplicate

### âž¤ **Time Complexity:**

O(n log n)

### âž¤ **Space Complexity:**

O(1) or O(n) depending on sorting algorithm

---

# ðŸš€ **Optimal Approach (HashSet)**

### âž¤ **Logic**

Use a set to store seen numbers.
If a number already exists in the set â†’ duplicate.

### âž¤ **Why optimal?**

HashSet operations (add, contains) are O(1) average time.

### âž¤ **Time Complexity:**

O(n)

### âž¤ **Space Complexity:**

O(n)

---

# âœ… **Optimal Java Code**

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for (int n : nums) {
            if (set.contains(n)) return true;
            set.add(n);
        }
        return false;
    }
}
