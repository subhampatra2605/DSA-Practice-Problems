# ğŸ“Œ 75. Sort Colors

(**Dutch National Flag Algorithm**)

---

# ğŸ§  Problem Type

* **Category:** Array
* **Pattern:** 3-Pointer Partitioning
* **Concept:** In-place sorting of 3 distinct values

---

# ğŸ¯ Core Goal

Sort array containing only:

```
0 â†’ Red
1 â†’ White
2 â†’ Blue
```

Constraints:

* Must be **in-place**
* Cannot use built-in sort
* Preferably **one-pass**

---

# ğŸš€ Optimal Approach (One Pass)

Use **three pointers**:

```
low  â†’ next position of 0
mid  â†’ current element
high â†’ next position of 2
```

---

# ğŸ“Œ Maintain This Invariant

```
[0 ... low-1] â†’ all 0s
[low ... mid-1] â†’ all 1s
[mid ... high] â†’ unknown
[high+1 ... n-1] â†’ all 2s
```

---

# ğŸ” Rules Inside Loop

While `mid <= high`:

### ğŸŸ¢ If nums[mid] == 0

* Swap with `low`
* `low++`
* `mid++`

### âšª If nums[mid] == 1

* Just `mid++`

### ğŸ”µ If nums[mid] == 2

* Swap with `high`
* `high--`
* DO NOT increment `mid`

---

# âš ï¸ Why Not Increment mid When It's 2?

Because after swapping with `high`,
the new element at `mid` is unprocessed.

We must re-check it.

---

# â± Complexity

* **Time:** O(n)
* **Space:** O(1)

Single traversal. Constant space.

---

# ğŸ§  Why This Is Important

This is a variation of:

* QuickSort partition
* 3-way partitioning
* In-place array classification

Very common in:

* FAANG interviews
* Product-based companies

---

# ğŸ†š Alternative Approach (2-Pass Counting)

1. Count 0s, 1s, 2s
2. Overwrite array

Time: O(n)
Space: O(1)
But requires two passes.

Interviewers prefer **Dutch Flag solution**.

---

# ğŸ† Interview Explanation (Short Version)

> I use three pointers (low, mid, high) to partition the array into three regions. I swap elements based on their value while maintaining invariants. This allows sorting in one pass with O(1) space.

---

# ğŸ”¥ Pattern Tag

Remember this as:

ğŸ‘‰ **â€œ3-way in-place partitionâ€**

Related problems:

* Partition Array
* QuickSort partition logic
* Wiggle Sort variants
