# âœ… **Problem 5: Top K Frequent Elements**

## ğŸ”¹ **Problem Statement**

Given an integer array `nums` and an integer `k`, return the **k most frequent elements**.

---

## ğŸ“¥ **Example Input**

```
nums = [1,1,1,2,2,3]
k = 2
```

## ğŸ“¤ **Output**

```
[1, 2]
```

---

# ğŸ’€ **Brute Force Approach**

1. Build frequency map
2. Sort numbers by frequency
3. Return top k

### âŒ Time Complexity: **O(n log n)**

### âŒ Space Complexity: **O(n)**

---

# ğŸš€ **Optimal Approach (Using Priority Queue / Min-Heap)**

### ğŸ”¥ Core Idea

* Count frequency of each number
* Use a **min-heap** of size **k**
* Heap stores numbers with **lowest frequency at the top**
* If heap size exceeds k â†’ remove least frequent number
* Remaining elements are the top k frequent

---

## âœ”ï¸ **Why Min-Heap Works**

* You only keep the **best k** elements at any time
* The element with the **lowest frequency** is always removed
* Faster than full sorting because heap never grows beyond size k

---

# â± **Time & Space Complexity**

| Step                  | Complexity     |
| --------------------- | -------------- |
| Build frequency map   | O(n)           |
| Push n keys into heap | O(n log k)     |
| Pop k elements        | O(k log k)     |
| **Total**             | **O(n log k)** |
| Space                 | **O(n)**       |

This is optimal for large arrays.

---

# ğŸ§© **Java Code (Optimal â€“ Priority Queue / Min-Heap)**

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        
        // If k equals array length, return whole array
        if (k == nums.length) {
            return nums;
        }

        // 1) Count frequencies
        Map<Integer, Integer> count = new HashMap<>();
        for (int n : nums) {
            count.put(n, count.getOrDefault(n, 0) + 1);
        }

        // 2) Min-heap based on frequency (smallest freq at top)
        Queue<Integer> heap = new PriorityQueue<>(
            (a, b) -> count.get(a) - count.get(b)
        );

        // 3) Keep only the k most frequent elements in heap
        for (int num : count.keySet()) {
            heap.add(num);
            if (heap.size() > k) {
                heap.poll();   // remove least frequent
            }
        }

        // 4) Build result (heap now contains top k)
        int[] ans = new int[k];
        for (int i = k - 1; i >= 0; i--) {
            ans[i] = heap.poll();
        }

        return ans;
    }
}

Just tell me!
